# LG-CNS-

## 6/29 제출본 참고사항

### 코드 구조의 특징
- util 대신 일부 코드를 개선하여 '함수명2'와 같은 형태로 만든 util2 모듈을 이용하였다.

### Bassline 코드 실험으로 얻은 아이디어
- solution의 번들 정보를 확인해본 결과 주문은 최대 3개까지만 묶이며 4개까지 묶인 번들이 하나라도 있는 경우는 드물었다. (예시로, Bassline 결과 하나의 '번들 내 주문 수: 해당 빈도'는 다음과 같았다. '1: 25, 2: 65, 3: 15') -> 그러므로 번들은 주문 3개까지 묶는 경우만 고려해도 될 수 있다고 생각하였다.

### 기본 가정
- 총 비용이 적은 번들 상태에서 최적화를 시작하는 것이 대부분의 경우에 유리할 것이라고 생각한다. -> 비용이 적은 곳에서 출발하니까 오히려 local minimum에 갇히는 현상이 나타나지 않음을 가정한다.

### 주요 아이디어
- 번들을 묶을 때 출발지 사이가 서로 가깝고, 도착지 사이가 서로 가까운 주문끼리 묶을 수 있다면 해당 주문의 비용을 줄일 수 있을 것이다.
- 주문을 하나씩만 포함한 모든 번들의 모든 쌍을 이용해서, 만약 a와 b 번들이 있다고 할 때 그 둘이 각각 가진 주문의 (출발지 사이의 거리 + 도착지 사이의 거리)를 (a, b, dist)와 같은 튜플 형태로 저장한 다음 dist의 오름차순으로 정렬해서 거리가 가까운 조합을 먼저 탐색하도록 한다.
- 이후 모든 쌍을 탐색하면서 두 번들을 try_merging_bundles로 합칠 수 있다면 합치고 union find를 이용하여 합쳐진 번들의 위치를 효율적으로 기억한다.
- try_merging_bundles는 모든 라이더의 모든 출발지, 도착지 순열을 확인할 수 있게 수정하였다. 번들 내의 주문을 최대 3개까지만 허용한다면, 이러한 경우에도 충분히 빠른 속도가 나온다.

### 추가 작업
- draw_route_solution2는 draw_route_solution의 시각화 결과에서 주문 번호가 같이 보이도록 수정하였다.

### 기타 코멘트
- DIST 행렬 대신에 주문 좌표로 직접 거리를 계산해본 결과 유클리디언 거리 방식이 가장 근접하지만 정확히 같지는 않았다. 혹시라도 좌표를 사용하여 평균을 낼 필요가 있을지 몰라서 좌표를 통해 거리를 직접 계산하는 방식으로 해보았다.
- 구현 방식에 최소 스패닝 트리의 크루스칼 알고리즘을 응용하였다.

## 6/30 제출본 참고사항
- 출발지 사이의 거리, 도착지 사이의 거리 말고도 주문 ready time의 차이, 마감 시간의 차이, 출발지와 도착지 사이의 평균 거리 또한 가중치를 임의로 주어 반영하였음.
- 이때 적절한 가중치를 탐색하는 2중 for문을 이용하였으며, K=300일 때 4초 정도 소요됨.
